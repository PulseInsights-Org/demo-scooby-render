<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scooby AI - Voice Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #f8f9fa;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .container {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        .bot-name {
            font-size: 24px;
            font-weight: bold;
            color: #28a745;
            margin-bottom: 10px;
        }
        
        .pulse-core {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #6c757d;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .pulse-core.connected {
            background: #28a745;
        }
        
        .pulse-core.listening {
            background: #28a745;
        }
        
        .pulse-core.speaking {
            background: #ffc107;
        }
        
        .pulse-core.disconnected {
            background: #6c757d;
        }
        
        .wave-visualization {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.4s ease;
            gap: 3px;
        }
        
        .wave-visualization.active {
            opacity: 1;
        }
        
        .wave-bar {
            width: 4px;
            height: 8px;
            background: #28a745;
            border-radius: 2px;
            animation: waveAnimation 1.4s ease-in-out infinite;
        }
        
        .wave-bar:nth-child(2) { animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { animation-delay: 0.3s; }
        .wave-bar:nth-child(5) { animation-delay: 0.4s; }
        .wave-bar:nth-child(6) { animation-delay: 0.5s; }
        .wave-bar:nth-child(7) { animation-delay: 0.6s; }
        .wave-bar:nth-child(8) { animation-delay: 0.7s; }
        .wave-bar:nth-child(9) { animation-delay: 0.8s; }
        .wave-bar:nth-child(10) { animation-delay: 0.9s; }
        .wave-bar:nth-child(11) { animation-delay: 1s; }
        .wave-bar:nth-child(12) { animation-delay: 1.1s; }
        
        .wave-bar.speaking {
            background: #ffc107;
            animation-duration: 0.8s;
        }
        
        @keyframes waveAnimation {
            0%, 100% { 
                height: 8px;
                opacity: 0.6;
            }
            50% { 
                height: 40px;
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="bot-name">SCOOBY AI</div>
        <div class="pulse-core disconnected" id="pulseCore"></div>
        
        <div class="wave-visualization" id="waveVisualization">
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
        </div>
    </div>

    <script>
        let ws;
        let audioContext;
        let isModelSpeaking = false;
        const BOT_TYPE = 'scooby'; // This bot only responds to scooby messages

        const pulseCoreEl = document.getElementById('pulseCore');
        const waveVisualizationEl = document.getElementById('waveVisualization');
        
        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                console.log('Audio context initialized for Scooby AI');
            } catch (error) {
                console.error('Failed to initialize audio context:', error);
            }
        }

        function connectWebSocket() { 
            const wsUrl = `wss://demo-scooby-render.onrender.com/ws`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('Scooby AI connected to WebSocket');
                updateStatus('connected');
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            ws.onclose = function() {
                console.log('Scooby AI WebSocket connection closed');
                updateStatus('disconnected');
                setTimeout(connectWebSocket, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('Scooby AI WebSocket error:', error);
                updateStatus('disconnected');
            };
        }

        function handleWebSocketMessage(data) {
            // Only handle messages intended for this bot
            if (data.bot_type && data.bot_type !== BOT_TYPE) {
                return; // Ignore messages for other bots
            }

            switch (data.type) {
                case 'status':
                    updateStatus(data.connected ? 'connected' : 'disconnected');
                    break;
                    
                case 'audio':
                    playAudio(data.data);
                    break;
                    
                case 'model_speaking':
                    isModelSpeaking = data.speaking;
                    if (data.speaking) {
                        updateStatus('speaking');
                        showWaveVisualization(true, 'speaking');
                        audioScheduleTime = audioContext ? audioContext.currentTime : 0;
                    } else {
                        updateStatus('connected');
                        showWaveVisualization(false);
                    }
                    break;
                    
                default:
                    console.log('Unknown message type:', data.type);
            }
        }
                          
        let audioScheduleTime = 0;

        function playAudio(base64Data) {
            if (!audioContext) {
                console.error('Audio context not initialized');
                return;
            }
            
            try {
                const raw = atob(base64Data);
                const bytes = new Uint8Array(raw.length);
                for (let i = 0; i < raw.length; i++) {
                    bytes[i] = raw.charCodeAt(i);
                }

                const wav = createWAVHeaderAndBlob(bytes, 24000);

                audioContext.decodeAudioData(wav.buffer, (decodedBuffer) => {
                    scheduleAudioChunk(decodedBuffer);
                }, (err) => {
                    console.error("decodeAudioData error:", err);
                });

            } catch (e) {
                console.error("Error processing audio:", e);
            }
        }

        function scheduleAudioChunk(audioBuffer) {
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);

            const currentTime = audioContext.currentTime;
            let startTime = Math.max(currentTime, audioScheduleTime);
            
            source.start(startTime);
            audioScheduleTime = startTime + audioBuffer.duration;
            
            console.log(`Scooby AI scheduled audio chunk: duration=${audioBuffer.duration.toFixed(3)}s`);
        }

        function createWAVHeaderAndBlob(pcmBytes, sampleRate = 24000) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmBytes.length;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            const writeString = (offset, str) => {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(36, 'data');
            view.setUint32(40, dataSize, true);

            new Uint8Array(buffer, 44).set(pcmBytes);
            return new Uint8Array(buffer);
        }

        function updateStatus(type) {
            pulseCoreEl.className = `pulse-core ${type}`;
        }
        
        function showWaveVisualization(show, type = 'listening') {
            if (show) {
                waveVisualizationEl.classList.add('active');
                const waveBars = waveVisualizationEl.querySelectorAll('.wave-bar');
                waveBars.forEach(bar => {
                    if (type === 'speaking') {
                        bar.classList.add('speaking');
                    } else {
                        bar.classList.remove('speaking');
                    }
                });
            } else {
                waveVisualizationEl.classList.remove('active');
                const waveBars = waveVisualizationEl.querySelectorAll('.wave-bar');
                waveBars.forEach(bar => {
                    bar.classList.remove('speaking');
                });
            }
        }

        document.addEventListener('DOMContentLoaded', async function() {
            await initAudio();
            connectWebSocket();
        });

        document.addEventListener('click', async function() {
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }
        });
    </script>
</body>
</html>
